<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="A platform for discussing programming and technology">
<meta property="og:type" content="website">
<meta property="og:title" content="BaniaBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BaniaBlog">
<meta property="og:description" content="A platform for discussing programming and technology">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Bania">
<meta property="article:tag" content="Python">
<meta property="article:tag" content=" Java">
<meta property="article:tag" content=" Machine Learning">
<meta property="article:tag" content=" Data Science">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BaniaBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="BaniaBlog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BaniaBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Sharing Technology</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Zbx2017/Zbx2017.github.io" class="github-corner" title="Bania GitHub" aria-label="Bania GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/Longest%20Common%20Subsequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/Longest%20Common%20Subsequence/" class="post-title-link" itemprop="url">Longest Common Subsequence</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-13 15:48:44 / Modified: 15:48:54" itemprop="dateCreated datePublished" datetime="2020-08-13T15:48:44+08:00">2020-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h3><p>从两个字符串中找到公共的最长子串：<br>例如：text1 = “abcad”<br>test2 = “acd”<br>最长公共子串为acd，放回3</p>
<p>如果直接使用暴力求解，效率低，同时问题会比较复杂，要考虑很多情况，比如，”abdac” 和”acd”，此时的最长子串为ac或者ad，放回为2，这里的子串是有一定的顺序的。而不能直接用两个for循环，依次比较每个位置的字符就能解决的。这种求法需要把所有的情况包括进行，比较复杂。</p>
<p>第二种方法是递归法，只需要考虑一个最小问题即可。</p>
<p>考虑两种情况：</p>
<p>text1 = “….x” 和 text2=”,,,,x”<br>假设text1长度为n，text2长度为m<br>省略的地方表示其他的字符，我们从后往前看。<br>最后一个字符相同，所以剩下的相同的子串会出现在前面的字符串中，因此我们只需要考虑text1剩下的n-1长度部分和text2的m-1长度部分</p>
<p>第二种情况是<br>text1 = “….y” 和 text2=”,,,,x”<br>最后一个字符不等，那么text1的前n-1的字符串可能会和text2有相同的子串，text2的前m-1的字符串也可能会和text1有相同的子串，最后取它们的最大的情况。</p>
<p>因此我们可以写出递归的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1, text2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type text1: str</span></span><br><span class="line"><span class="string">        :type text2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># brute force too complicated</span></span><br><span class="line">        <span class="comment"># recurse time exceeded</span></span><br><span class="line">        <span class="comment"># dp method</span></span><br><span class="line">        <span class="keyword">return</span> self.lcs(text1, text2, len(text1), len(text2))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcs</span><span class="params">(self,text1, text2, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="number">0</span> <span class="keyword">or</span> l2 == <span class="number">0</span>:</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> text1[l1<span class="number">-1</span>] == text2[l2<span class="number">-1</span>]:</span><br><span class="line">            result = self.lcs(text1, text2, l1<span class="number">-1</span>, l2<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp1 = self.lcs(text1,text2,l1<span class="number">-1</span>,l2)</span><br><span class="line">            temp2 = self.lcs(text1,text2,l1,l2<span class="number">-1</span>)</span><br><span class="line">            result = max(temp1, temp2)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line">text1 = <span class="string">"abcde"</span></span><br><span class="line">text2 = <span class="string">"ace"</span></span><br><span class="line">s.longestCommonSubsequence(text1, text2)</span><br><span class="line"><span class="comment"># output: 3</span></span><br></pre></td></tr></table></figure>
<p>在递归的基础上增加一个数组来保存每一次计算的值，那么就变成动态规划的memo方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1, text2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type text1: str</span></span><br><span class="line"><span class="string">        :type text2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># brute force too complicated</span></span><br><span class="line">        <span class="comment"># recurse time exceeded</span></span><br><span class="line">        <span class="comment"># dp method</span></span><br><span class="line">        l1 = len(text1) + <span class="number">1</span></span><br><span class="line">        l2 = len(text2) + <span class="number">1</span></span><br><span class="line">        arr = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(l2)] <span class="keyword">for</span> i <span class="keyword">in</span> range(l1)]</span><br><span class="line">        <span class="keyword">return</span> self.lcs(text1, text2, len(text1), len(text2), arr)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lcs</span><span class="params">(self,text1, text2, l1, l2, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> arr[l1][l2] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> arr[l1][l2]</span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="number">0</span> <span class="keyword">or</span> l2 == <span class="number">0</span>:</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> text1[l1<span class="number">-1</span>] == text2[l2<span class="number">-1</span>]:</span><br><span class="line">            result = self.lcs(text1, text2, l1<span class="number">-1</span>, l2<span class="number">-1</span>, arr) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp1 = self.lcs(text1,text2,l1<span class="number">-1</span>,l2, arr)</span><br><span class="line">            temp2 = self.lcs(text1,text2,l1,l2<span class="number">-1</span>, arr)</span><br><span class="line">            result = max(temp1, temp2)</span><br><span class="line">        arr[l1][l2] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">s = Solution()</span><br><span class="line">text1 = <span class="string">"abcde"</span></span><br><span class="line">text2 = <span class="string">"ace"</span></span><br><span class="line">s.longestCommonSubsequence(text1, text2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 3</span></span><br></pre></td></tr></table></figure>
<p>将上述的递归方法改成从下到上的模式，就是bottom-up 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1, text2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type text1: str</span></span><br><span class="line"><span class="string">        :type text2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># brute force too complicated</span></span><br><span class="line">        <span class="comment"># recurse time exceeded</span></span><br><span class="line">        <span class="comment"># dp method</span></span><br><span class="line">        <span class="comment"># bottom up</span></span><br><span class="line">        n = len(text1)</span><br><span class="line">        m = len(text2)</span><br><span class="line">        arr = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]:</span><br><span class="line">                    arr[i][j] = <span class="number">1</span> + arr[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    arr[i][j] = max(arr[i][j<span class="number">-1</span>],arr[i<span class="number">-1</span>][j])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">s = Solution()</span><br><span class="line">text1 = <span class="string">"abcde"</span></span><br><span class="line">text2 = <span class="string">"ace"</span></span><br><span class="line">s.longestCommonSubsequence(text1, text2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:3</span></span><br></pre></td></tr></table></figure>
<p>其核心的迭代公式是没有变的，时间复杂度为O(mn)，其运算的效率要比前两种方法快一点，代码也更简洁一点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/0-1%20Knapsack%20Problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/0-1%20Knapsack%20Problem/" class="post-title-link" itemprop="url">0-1 Knapsack Problem</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-13 15:16:35 / Modified: 15:21:23" itemprop="dateCreated datePublished" datetime="2020-08-13T15:16:35+08:00">2020-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="0-1-Knapsack-Problem"><a href="#0-1-Knapsack-Problem" class="headerlink" title="0-1 Knapsack Problem"></a>0-1 Knapsack Problem</h3><p>下面我们利用动态规划来解决一个实际问题叫做0-1背包问题。</p>
<p><img src="/2020/08/13/0-1%20Knapsack%20Problem/table.png" alt="img"></p>
<p>如上有两个数组，一个是重量，一个是对应的价值。每个东西只能放一次，现在给出一个容量C的背包，问怎么装这些东西使得价值最大。</p>
<p>对于每一个东西，都有两种选择，放进背包还是不放，因此5个东西有$2^5$种方法。这个问题是个最大化问题，那么每一次决定都要使得value最大化。</p>
<p>首先我们用简单的递归来实现。</p>
<p>从后往前遍历，每个物体有放和不放的情况，如果是不放，那么直接跳到前一个物体，如果放，此时的value是当前放进的物体的value和剩余还没有放的value之后。</p>
<p>1.递归退出条件：东西装完了或者容量达到最大了<br>2.递归过程：<br>设函数为knp(n, C)<br>放进背包：v1 = v[n] + knp(n-1, C-w[i])<br>不放：v2 = knp(n-1,C)<br>vmax = max(v1, v2)<br>同时考虑一定不能放进背包的情况：重量大于容量<br>3.放回结果</p>
<p>代码如下，设c为10，计算得出的最大价值为16，与人工计算的结果相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">w = [<span class="literal">None</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">v = [<span class="literal">None</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knp</span><span class="params">(n, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> c ==<span class="number">0</span> :</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> w[n] &gt; c:</span><br><span class="line">        result = knp(n<span class="number">-1</span>, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp1 = v[n] + knp(n<span class="number">-1</span>, c-w[n])</span><br><span class="line">        temp2 = knp(n<span class="number">-1</span>, c)</span><br><span class="line">        result = max(temp1, temp2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">print(knp(<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># output: 16</span></span><br></pre></td></tr></table></figure>
<p>递归的方法尝试了所有的情况，其时间复杂度为$O(2^n)$，现在我们用动态规划的方法，修改上面的代码，同时用一个列表keep来标记哪个物体被放进背包里面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">w = [<span class="literal">None</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">v = [<span class="literal">None</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">arr = np.zeros([<span class="number">6</span>,<span class="number">11</span>])</span><br><span class="line">keep = [<span class="number">0</span>]*<span class="number">6</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knp</span><span class="params">(n, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> arr[n][c] != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[n][c]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> c ==<span class="number">0</span> :</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> w[n] &gt; c:</span><br><span class="line">        result = knp(n<span class="number">-1</span>, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp1 = v[n] + knp(n<span class="number">-1</span>, c-w[n])</span><br><span class="line">        temp2 = knp(n<span class="number">-1</span>, c)</span><br><span class="line">        <span class="keyword">if</span> temp1 &gt; temp2:</span><br><span class="line">            result = temp1</span><br><span class="line">            keep[n] = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = temp2</span><br><span class="line">    arr[n][c] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">print(knp(<span class="number">5</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># output: 16</span></span><br><span class="line">print(keep)</span><br><span class="line"><span class="comment"># [0, 1, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">什么是动态规划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-13 15:04:34 / Modified: 15:21:15" itemprop="dateCreated datePublished" datetime="2020-08-13T15:04:34+08:00">2020-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>什么是动态规划？举一个例子来说明：Fibonacci number</p>
<p>Fibonacci number 的定义是：</p>
<p>F[n] = F[n-1] + F[n-2], 当n=1，2时 F[n] = 1</p>
<p>那么如何用编程实现Fibonacci number（FN）的求解呢？如果我们定义一个函数fib(n)来求解n的FN，比如当我们求n=5时的Fibonacci number，我们需要知道n=4和n=3的Fibonacci number， 而要知道n=4和n=3的FN，我们需要知道n=3，2，1的FN，依此类推。这个过程需要不断地调用fib函数，这个过程就是递归。因此我们的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">print(fib(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 5</span></span><br></pre></td></tr></table></figure>
<p>但是如果n比较大的时候，递归方法求解起来的速度会很慢,下面n为35的求解用了4秒钟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line">print(fib(<span class="number">35</span>))</span><br><span class="line">endtime = datetime.datetime.now()</span><br><span class="line"><span class="keyword">print</span> ((endtime - starttime).seconds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># 9227465</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<p>为什么当n变大了，递归的求解方法会变慢呢？再回到n=5时的例子，求F[5]需要知道F[4]和F[3]，而要知道F[4]，我们要求出F[3]和F[2]；要知道F[3]，我们要求出F[2]和F[1]。这里就可以明显看到，F[3]和F[2]都被重复计算了，这样就导致了效率低。实际上求解FN的递归方法的时间复杂度是指数型: $O(2^n)$。因此，如果我们消除这么多的重复计算，那么效率就会得到一定的提高。</p>
<p>那么怎么消除重复计算呢？如果在求F[4]的时候保存了F[3]的值，那么求解F[3]的时候就可以直接使用，避免了再次计算。因此我们可以用一个数组保存当前的n对应的FN。修改以下上面的代码，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = [<span class="literal">None</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> res[n] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res[n]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = fib(n<span class="number">-1</span>, res)+fib(n<span class="number">-2</span>, res)</span><br><span class="line">        res[n] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> fib(n, res)</span><br></pre></td></tr></table></figure>
<p>这时在看看计算n为35的FN的值所用的时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line">print(fib(<span class="number">35</span>))</span><br><span class="line">endtime = datetime.datetime.now()</span><br><span class="line"><span class="keyword">print</span> ((endtime - starttime).seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br><span class="line"><span class="comment"># 0:00:00.000458</span></span><br></pre></td></tr></table></figure>
<p>可以明显看到所用的时间比之前小得多。</p>
<p>上述的例子就是一个动态规划的例子，概括性地讲，动态规划类似于递归+存储（recursion&amp;memoization），再递归过程中可以避免不必要的重复计算。</p>
<p>同时上述例子还可以改成另外一个版本的动态规划叫做Bottom-up approach。除了用递归，我们还可以直接用一个数组保存1到n的FN，从1到n开始循环，其时间复杂度和上述的方法相同都是O(n)。这种方法这这个例子中使用起来比较清晰易懂，但不代表所有的情况都适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    res = [<span class="literal">None</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] + res[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2/" class="post-title-link" itemprop="url">最短路径算法-2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 18:12:26" itemprop="dateCreated datePublished" datetime="2020-08-12T18:12:26+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-13 11:42:24" itemprop="dateModified" datetime="2020-08-13T11:42:24+08:00">2020-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="最短路径算法-2"><a href="#最短路径算法-2" class="headerlink" title="最短路径算法-2"></a>最短路径算法-2</h3><p>在这部分的最短路径算法中，我将介绍两种算法：Dijkstra和Bellman-Ford算法。</p>
<h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p>Dijkstra算法是用来求两点之间最短路径的算法，适用于正权图，算法流程如下：</p>
<p>1.将所有节点标记为未访问并将其存储。<br>2.将初始节点的距离设置为零，将其他节点的距离设置为无穷大。<br>3.选择距离最近的未访问节点，它是当前节点。<br>4.查找当前节点的未访问邻居，并计算它们到当前节点的距离。将新计算的距离与分配的距离进行比较，然后保存较小的距离。<br>5.将当前节点标记为已访问，并将其从未访问的集中删除。<br>6.如果访问了目标节点（在计划两个特定节点之间的路由时），或者未访问的节点之间的最小距离是无穷大，则停止。如果不是，请重复步骤3-6。</p>
<p>下面我们结合一个实际的例子来说明上述算法流程，假设集合S保存访问过的节点，集合Q保存未访问的节点。</p>
<p><img src="/2020/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2/graph.png" alt="1597225072251"></p>
<p>如上图，每一条边的权重都是正数，现在需要找到A到B的最短路径。首先将所有节点保存在Q中，初始节点距离为0，其余节点的距离为无穷大。接着，选择距离最近的未访问节点A为当前节点，查找当前节点的未访问邻居（B、C），并计算它们到当前节点的距离（10，3），将新计算的距离与分配的距离（无穷大)进行比较，然后保存较小的距离（10，3）。将当前节点标记为已访问，并将其从未访问的集中删除（Q集合删掉A节点）。一直重复上述步骤直到访问到了节点B，如图中所示。这时即可得出A到B的最短路径为7。</p>
<p>下面根据上述算法流程来编写程序，可以看到我们每次需要选择距离最短的节点进行访问，那么可以利用优先队列数据结构实现这个过程。利用二叉堆实现的优先队列的时间复杂度更小，可以提高算法效率。</p>
<p>算法中所用的优先队列代码如下，其详细介绍在上一篇博客。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line"><span class="string">"""Min-heap-based priority queue, using 1-based indexing. Adapted from CLRS.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Augmented to include a map of keys to their indices in the heap so that</span></span><br><span class="line"><span class="string">key lookup is constant time and decrease_key(key) is O(log n) time.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Initializes the priority queue."""</span></span><br><span class="line">    self.heap = [<span class="literal">None</span>] <span class="comment"># To make the index 1-based.</span></span><br><span class="line">    self.key_index = &#123;&#125; <span class="comment"># key to index mapping.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.heap) - <span class="number">1</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.heap[i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, i, key)</span>:</span></span><br><span class="line">    self.heap[i] = key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"""Decreases the value of the key if it is in the priority queue and </span></span><br><span class="line"><span class="string">    maintains the heap property."""</span></span><br><span class="line">    index = self.key_index[key]</span><br><span class="line">    <span class="keyword">if</span> index:</span><br><span class="line">        self._decrease_key(index, key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, key)</span>:</span></span><br><span class="line">    <span class="string">"""Inserts a key into the priority queue."""</span></span><br><span class="line">    self.heap.append(key)</span><br><span class="line">    self.key_index[key] = len(self)</span><br><span class="line">    self._decrease_key(len(self), key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_min</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Removes and returns the minimum key."""</span></span><br><span class="line">    <span class="keyword">if</span> len(self) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    self._swap(<span class="number">1</span>, len(self))</span><br><span class="line">    min = self.heap.pop()</span><br><span class="line">    <span class="keyword">del</span> self.key_index[min]</span><br><span class="line">    self._min_heapify(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decrease_key</span><span class="params">(self, i, key)</span>:</span></span><br><span class="line">    <span class="string">"""Decreases key at a give index.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        i: index of the key.</span></span><br><span class="line"><span class="string">        key: key with decreased value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        parent = i // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self[parent] &gt; key:</span><br><span class="line">            self._swap(i, parent)</span><br><span class="line">            i = parent</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_min_heapify</span><span class="params">(self, i)</span>:</span></span><br><span class="line">    <span class="string">"""Restores the heap property from index i downwards."""</span></span><br><span class="line">    l = <span class="number">2</span> * i</span><br><span class="line">    r = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    smallest = i</span><br><span class="line">    <span class="keyword">if</span> l &lt;= len(self) <span class="keyword">and</span> self[l] &lt; self[i]:</span><br><span class="line">        smallest = l</span><br><span class="line">    <span class="keyword">if</span> r &lt;= len(self) <span class="keyword">and</span> self[r] &lt; self[smallest]:</span><br><span class="line">        smallest = r</span><br><span class="line">    <span class="keyword">if</span> smallest != i:</span><br><span class="line">        self._swap(i, smallest)</span><br><span class="line">        self._min_heapify(smallest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">    <span class="comment"># Swaps the key at indices i and j and updates the key to index map.</span></span><br><span class="line">    self.heap[i], self.heap[j] = self.heap[j], self.heap[i]</span><br><span class="line">    self.key_index[self.heap[i]], self.key_index[self.heap[j]] = i, j</span><br></pre></td></tr></table></figure>
<p>同时需要NodeDistancePair类将节点封装起来，以便优先队列根据距离取出节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeDistancePair</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Wraps a node and its distance representing it in the priority queue."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node, distance)</span>:</span></span><br><span class="line">        <span class="string">"""Creates a NodeDistancePair to be used as a key in the priority queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.node = node</span><br><span class="line">        self.distance = distance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.distance &lt; other.distance <span class="keyword">or</span></span><br><span class="line">                (self.distance == other.distance <span class="keyword">and</span></span><br><span class="line">                 id(self.node) &lt; id(other.node)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.distance &lt; other.distance <span class="keyword">or</span></span><br><span class="line">                (self.distance == other.distance <span class="keyword">and</span></span><br><span class="line">                 id(self.node) &lt;= id(other.node)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.distance &gt; other.distance <span class="keyword">or</span></span><br><span class="line">                (self.distance == other.distance <span class="keyword">and</span></span><br><span class="line">                 id(self.node) &gt; id(other.node)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.distance &gt; other.distance <span class="keyword">or</span></span><br><span class="line">                (self.distance == other.distance <span class="keyword">and</span></span><br><span class="line">                 id(self.node) &gt;= id(other.node)))</span><br></pre></td></tr></table></figure>
<p>graph也需要一个类进行封装，定义其表示的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, d=None, p=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.d = d</span><br><span class="line">        self.p = p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vertex, edge, weight)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param vertex: list of vertices</span></span><br><span class="line"><span class="string">        :param edge: dict of the edges</span></span><br><span class="line"><span class="string">        :param weight: dict of the weight</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.vertex = [Vertex(v) <span class="keyword">for</span> v <span class="keyword">in</span> vertex]</span><br><span class="line">        self.edge = edge</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_vertex</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> self.vertex:</span><br><span class="line">            <span class="keyword">if</span> name == v.name:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        index = u + v</span><br><span class="line">        <span class="keyword">return</span> self.weight[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_adj</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.edge[node]</span><br></pre></td></tr></table></figure>
<p>Dijkstra代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(graph, source, destination)</span>:</span></span><br><span class="line">       <span class="string">"""Performs Dijkstra's algorithm until it finds the shortest</span></span><br><span class="line"><span class="string">       path from source to destination in the graph with nodes and edges.</span></span><br><span class="line"><span class="string">       Assumes that all weights are non-negative.</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">       Args:</span></span><br><span class="line"><span class="string">           graph: the graph to be implemented</span></span><br><span class="line"><span class="string">           source: the source node in the graph.</span></span><br><span class="line"><span class="string">           destination: the destination node in the graph.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">       Returns:</span></span><br><span class="line"><span class="string">           A tuple of the path as a list of nodes from source to destination </span></span><br><span class="line"><span class="string">           and the number of visited nodes.</span></span><br><span class="line"><span class="string">       """</span></span><br><span class="line">       Q = PriorityQueue()</span><br><span class="line">       <span class="comment"># 初始化</span></span><br><span class="line">       <span class="keyword">for</span> node <span class="keyword">in</span> graph.vertex:</span><br><span class="line">           node.parent = <span class="literal">None</span></span><br><span class="line">           node.queue_key = <span class="literal">None</span></span><br><span class="line">       <span class="comment"># 起始节点添加进队列，表示已经访问</span></span><br><span class="line">       source = graph.get_vertex(source)</span><br><span class="line">       source.queue_key = NodeDistancePair(source, <span class="number">0</span>)</span><br><span class="line">       Q.insert(source.queue_key)</span><br><span class="line">       num_visited = <span class="number">0</span></span><br><span class="line">       <span class="keyword">while</span> len(Q) &gt; <span class="number">0</span>:</span><br><span class="line">           <span class="comment"># 获取队列中离当前节点距离最近的节点</span></span><br><span class="line">           u = Q.extract_min()</span><br><span class="line">           num_visited = num_visited + <span class="number">1</span></span><br><span class="line">           <span class="comment"># 判断是否为目标节点</span></span><br><span class="line">           <span class="keyword">if</span> u.node <span class="keyword">is</span> destination:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="comment"># 遍历当前节点的邻居节点 </span></span><br><span class="line">           <span class="keyword">for</span> next_vertex <span class="keyword">in</span> graph.get_adj(u.node):</span><br><span class="line">               <span class="comment"># 算下一节点到当前节点的距离</span></span><br><span class="line">               next_dist = graph.weight(u.node, next_vertex) + u.distance</span><br><span class="line">               next = graph.get_vertex(next_vertex)</span><br><span class="line">               <span class="comment"># 没有被访问，则添加进队列</span></span><br><span class="line">               <span class="keyword">if</span> next.queue_key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                   next.queue_key = NodeDistancePair(next.name, next_dist)</span><br><span class="line">                   Q.insert(next.queue_key)</span><br><span class="line">                   next.parent = u.node</span><br><span class="line">               <span class="comment"># 有被访问过，则重新计算距离并更新</span></span><br><span class="line">               <span class="keyword">elif</span> next_dist &lt; next.queue_key.distance:</span><br><span class="line">                   next.queue_key.distance = next_dist</span><br><span class="line">                   Q.decrease_key(next.queue_key)</span><br><span class="line">                   next.parent = u.node</span><br><span class="line">                   </span><br><span class="line">       <span class="comment">#反向遍历找到源节点到目标节点的路径</span></span><br><span class="line">       p = []</span><br><span class="line">       des = graph.get_vertex(destination)</span><br><span class="line">       <span class="keyword">while</span> des <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           p.append(des.name)</span><br><span class="line">           des = graph.get_vertex(des.parent)</span><br><span class="line">       p.reverse()</span><br><span class="line">       <span class="keyword">return</span> (p, num_visited)</span><br></pre></td></tr></table></figure>
<p>对代码进行简单的测试，其计算所得的路径和路径长度与人工计算的结果相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph1 = Graph(vertex=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">               edge=&#123;<span class="string">'A'</span>:[<span class="string">'B'</span>,<span class="string">'C'</span>],</span><br><span class="line">                     <span class="string">'B'</span>:[<span class="string">'C'</span>,<span class="string">'D'</span>],</span><br><span class="line">                     <span class="string">'C'</span>:[<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'D'</span>:[<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'E'</span>:[<span class="string">'D'</span>]&#125;,</span><br><span class="line">               weight=&#123;<span class="string">'AB'</span>:<span class="number">10</span>,<span class="string">'AC'</span>:<span class="number">3</span>,<span class="string">'BD'</span>:<span class="number">2</span>,<span class="string">'BC'</span>:<span class="number">1</span>,<span class="string">'CB'</span>:<span class="number">4</span>,</span><br><span class="line">                       <span class="string">'CD'</span>:<span class="number">8</span>,<span class="string">'CE'</span>:<span class="number">2</span>,<span class="string">'DE'</span>:<span class="number">7</span>,<span class="string">'ED'</span>:<span class="number">9</span>&#125;)</span><br><span class="line"></span><br><span class="line">print(dijkstra(graph1, <span class="string">'A'</span>,<span class="string">'D'</span>))</span><br><span class="line">print(graph1.get_vertex(<span class="string">'D'</span>).queue_key.distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: (['A', 'C', 'B', 'D'], 5)  9</span></span><br></pre></td></tr></table></figure>
<p>利用二叉堆实现的Dijkstra算法的时间复杂度为 O(<em>V</em> lg <em>V</em> + <em>E</em> lg <em>V</em> )。</p>
<h5 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h5><p>当图中有负权边时，有些情况下Dijkstra算法将不再适用，例如下述情况中出现了negative cycle，若采用Dijkstras算法，程序将无法停止，会进入死循环。因此需要一种算法可以检测neagtive cycles。</p>
<p><img src="/2020/08/12/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2/negative.png" alt="img"></p>
<p>与Dijkstra算法相比，Bellman-Ford算法比较简单，在寻找最短路径时，它不像Dijkstra算法那样每次选择最近的节点，因此不需要优先队列的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, d=None, p=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.d = d</span><br><span class="line">        self.p = p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vertex, edge, weight)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param vertex: list of vertices</span></span><br><span class="line"><span class="string">        :param edge: dict of the edges</span></span><br><span class="line"><span class="string">        :param weight: dict of the weight</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.vertex_string = vertex</span><br><span class="line">        self.vertex = [Vertex(v) <span class="keyword">for</span> v <span class="keyword">in</span> vertex]</span><br><span class="line">        self.edge = edge</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_vertex</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> self.vertex:</span><br><span class="line">            <span class="keyword">if</span> name == v.name:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">V</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.vertex_string</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">E</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.edge</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">w</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        index = u + v</span><br><span class="line">        <span class="keyword">return</span> self.weight[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_single_source</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> self.vertex:</span><br><span class="line">            v.d = float(<span class="string">'Inf'</span>)</span><br><span class="line">            v.p = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> s == v.name:</span><br><span class="line">                v.d = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        ve = self.get_vertex(v)</span><br><span class="line">        ue = self.get_vertex(u)</span><br><span class="line">        <span class="keyword">if</span> ve.d &gt; ue.d + self.w(u, v):</span><br><span class="line">            print(<span class="string">"negative cycle appears"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(self, u, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param u: curr vertex</span></span><br><span class="line"><span class="string">        :param v: next vertex</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ve = self.get_vertex(v)</span><br><span class="line">        ue = self.get_vertex(u)</span><br><span class="line">        <span class="keyword">if</span> ve.d &gt; ue.d + self.w(u, v):</span><br><span class="line">            ve.d = ue.d + self.w(u, v)</span><br><span class="line">            ve.p = ue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_adj</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.edge[node]</span><br></pre></td></tr></table></figure>
<p>上面的代码用来表示图，下面是Bellman-Ford算法。首先对图进行了初始化，源节点的距离设置为0，其余节点设置为无穷大。对图中的每条边进行遍历更新距离，迭代|V-1|次，V是图的节点数。最后一步检测是否存在negative cycles，即判断是否存在ve.d &gt; ue.d + w(u, v)的情况，其中ue为当前节点，ve为下一节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(G, s)</span>:</span></span><br><span class="line">    G.initialize_single_source(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(G.V())):</span><br><span class="line">        <span class="keyword">for</span> vertex <span class="keyword">in</span> G.E():</span><br><span class="line">            <span class="keyword">for</span> next_vertex <span class="keyword">in</span> G.E()[vertex]:</span><br><span class="line">                G.relax(vertex, next_vertex)</span><br><span class="line">    <span class="keyword">for</span> vertex <span class="keyword">in</span> G.E():</span><br><span class="line">        <span class="keyword">for</span> next_vertex <span class="keyword">in</span> G.E()[vertex]:</span><br><span class="line">            G.check(vertex, next_vertex)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 图中有negative cycle时：</span></span><br><span class="line">graph1 = Graph(vertex=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">               edge=&#123;<span class="string">'A'</span>:[<span class="string">'B'</span>,<span class="string">'C'</span>],</span><br><span class="line">                     <span class="string">'B'</span>:[<span class="string">'C'</span>,<span class="string">'D'</span>],</span><br><span class="line">                     <span class="string">'C'</span>:[<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'D'</span>:[<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'E'</span>:[<span class="string">'D'</span>]&#125;,</span><br><span class="line">               weight=&#123;<span class="string">'AB'</span>:<span class="number">10</span>,<span class="string">'AC'</span>:<span class="number">3</span>,<span class="string">'BD'</span>:<span class="number">2</span>,<span class="string">'BC'</span>:<span class="number">1</span>,<span class="string">'CB'</span>:<span class="number">-4</span>,</span><br><span class="line">                       <span class="string">'CD'</span>:<span class="number">8</span>,<span class="string">'CE'</span>:<span class="number">2</span>,<span class="string">'DE'</span>:<span class="number">7</span>,<span class="string">'ED'</span>:<span class="number">9</span>&#125;)</span><br><span class="line">bellman_ford(graph1, <span class="string">'A'</span>)</span><br><span class="line">print(graph1.get_vertex(<span class="string">'B'</span>).d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># negative cycle appears</span></span><br><span class="line"><span class="comment"># negative cycle appears</span></span><br><span class="line"><span class="comment"># -13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改权重：计算的距离与人工手算相同</span></span><br><span class="line">graph1 = Graph(vertex=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">               edge=&#123;<span class="string">'A'</span>:[<span class="string">'B'</span>,<span class="string">'C'</span>],</span><br><span class="line">                     <span class="string">'B'</span>:[<span class="string">'C'</span>,<span class="string">'D'</span>],</span><br><span class="line">                     <span class="string">'C'</span>:[<span class="string">'B'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'D'</span>:[<span class="string">'E'</span>],</span><br><span class="line">                     <span class="string">'E'</span>:[<span class="string">'D'</span>]&#125;,</span><br><span class="line">               weight=&#123;<span class="string">'AB'</span>:<span class="number">10</span>,<span class="string">'AC'</span>:<span class="number">3</span>,<span class="string">'BD'</span>:<span class="number">2</span>,<span class="string">'BC'</span>:<span class="number">1</span>,<span class="string">'CB'</span>:<span class="number">4</span>,</span><br><span class="line">                       <span class="string">'CD'</span>:<span class="number">8</span>,<span class="string">'CE'</span>:<span class="number">2</span>,<span class="string">'DE'</span>:<span class="number">7</span>,<span class="string">'ED'</span>:<span class="number">9</span>&#125;)</span><br><span class="line"><span class="comment"># output: 7</span></span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O(VE)，因为初始化需要O(V)时间，对E条边进行遍历更新距离，迭代|V-1|次需要O(VE)时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/Priority%20queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/Priority%20queue/" class="post-title-link" itemprop="url">Priority queue</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-11 17:39:15 / Modified: 17:42:18" itemprop="dateCreated datePublished" datetime="2020-08-11T17:39:15+08:00">2020-08-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Priority-queue-优先队列"><a href="#Priority-queue-优先队列" class="headerlink" title="Priority queue(优先队列)"></a>Priority queue(优先队列)</h3><p>队列是一种满足先进先出原则的数据结构，在Python中利用列表就可以简单地实现一个队列。首先需要定义一个列表，接在在列表中加入元素，最后利用pop方法将最先加入的元素取出，即可实现一个队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue = []</span><br><span class="line">queue.append(<span class="number">2</span>)</span><br><span class="line">queue.append(<span class="number">3</span>)</span><br><span class="line">queue.append(<span class="number">1</span>)</span><br><span class="line">queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: 2</span></span><br></pre></td></tr></table></figure>
<p>队列的应用很多，比如在BFS算法中就使用到了队列的数据结构。但在有些场合中，我们不需要按照时间的先后顺序来取出元素，而是根据优先等级来取元素，这时就需要优先队列这种数据结构。</p>
<p>简单地说，优先队列也会像队列一样保存一些元素，但取出元素的方式会按照元素的等级进行，一般有最大优先队列和最小优先队列之分，前者每次取出的是最大等级的元素，后者取出的是最小等级的元素。按照这种说法，我们可以将上面的代码简单修改一下就实现了优先队列的功能。</p>
<p>比如我们按照客户的VIP等级对客户提供服务，级别高的先服务。首先把客户和其VIP等级添加进队列里，接着将列表降序排序，输出第一个元素即是VIP等级最高的客户。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pq = []</span><br><span class="line">pq.append((<span class="number">2</span>,<span class="string">"Tom"</span>))</span><br><span class="line">pq.append((<span class="number">3</span>,<span class="string">"Tina"</span>))</span><br><span class="line">pq.append((<span class="number">1</span>,<span class="string">"Tony"</span>))</span><br><span class="line">pq.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">pq.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output: (3,"Tina")</span></span><br></pre></td></tr></table></figure>
<p>利用列表实现的优先队列虽然简单，但其扩展性较差，比如我们希望输出客户这个对象，而不是将加入列表里面的内容全部输出，这时的列表将不能满足这个功能。同时调用<code>pop</code>方法，会改变剩下元素的索引，其时间复杂度为O(n)。那么有什么方法可以减少时间复杂度，同时提供优先队列的扩展性呢？</p>
<p>上面代码中，当我们取出最高等级的元素时，所用的时间复杂度为O(n)，用何种数据结构可以使得取出最大值或者最小值的时间复杂度小于O(n)呢？二叉堆可以做到，在<code>Heapsort</code>中，我们可以看到对于最大堆，取出最大元素只要取出第一个元素即可，同时调用<code>Max-heapify</code>方法使树的结构满足堆的特性。该方法的时间复杂度为O(logn)，因此完成取出最大值的时间复杂度为O(logn)，要小于线性时间。</p>
<p>下面我将介绍如何利用二叉堆来设计一个优先队列，我将以最小优先队列为例进行介绍。</p>
<p>最主要需要三个方法：</p>
<ul>
<li><code>Insert</code>: 插入元素</li>
<li><code>Extract_Min</code>: 取出最小等级的元素</li>
<li><code>Decrease_Key</code>: 减小某一元素的等级，减小之后需要交换元素以满足堆的特性。</li>
</ul>
<p>Python代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="string">"""Min-heap-based priority queue, using 1-based indexing. Adapted from CLRS.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Augmented to include a map of keys to their indices in the heap so that</span></span><br><span class="line"><span class="string">    key lookup is constant time and decrease_key(key) is O(log n) time.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Initializes the priority queue."""</span></span><br><span class="line">        self.heap = [<span class="literal">None</span>] <span class="comment"># To make the index 1-based.</span></span><br><span class="line">        self.key_index = &#123;&#125; <span class="comment"># key to index mapping.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.heap) - <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.heap[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, i, key)</span>:</span></span><br><span class="line">        self.heap[i] = key</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease_key</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""Decreases the value of the key if it is in the priority queue and </span></span><br><span class="line"><span class="string">        maintains the heap property."""</span></span><br><span class="line">        index = self.key_index[key]</span><br><span class="line">        <span class="keyword">if</span> index:</span><br><span class="line">            self._decrease_key(index, key)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""Inserts a key into the priority queue."""</span></span><br><span class="line">        self.heap.append(key)</span><br><span class="line">        self.key_index[key] = len(self)</span><br><span class="line">        self._decrease_key(len(self), key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Removes and returns the minimum key."""</span></span><br><span class="line">        <span class="keyword">if</span> len(self) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self._swap(<span class="number">1</span>, len(self))</span><br><span class="line">        min = self.heap.pop()</span><br><span class="line">        <span class="keyword">del</span> self.key_index[min]</span><br><span class="line">        self._min_heapify(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> min</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_decrease_key</span><span class="params">(self, i, key)</span>:</span></span><br><span class="line">        <span class="string">"""Decreases key at a give index.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            i: index of the key.</span></span><br><span class="line"><span class="string">            key: key with decreased value.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            parent = i // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self[parent] &gt; key:</span><br><span class="line">                self._swap(i, parent)</span><br><span class="line">                i = parent</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_min_heapify</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="string">"""Restores the heap property from index i downwards."""</span></span><br><span class="line">        l = <span class="number">2</span> * i</span><br><span class="line">        r = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        smallest = i</span><br><span class="line">        <span class="keyword">if</span> l &lt;= len(self) <span class="keyword">and</span> self[l] &lt; self[i]:</span><br><span class="line">            smallest = l</span><br><span class="line">        <span class="keyword">if</span> r &lt;= len(self) <span class="keyword">and</span> self[r] &lt; self[smallest]:</span><br><span class="line">            smallest = r</span><br><span class="line">        <span class="keyword">if</span> smallest != i:</span><br><span class="line">            self._swap(i, smallest)</span><br><span class="line">            self._min_heapify(smallest)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_swap</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="comment"># Swaps the key at indices i and j and updates the key to index map.</span></span><br><span class="line">        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]</span><br><span class="line">        self.key_index[self.heap[i]], self.key_index[self.heap[j]] = i, j</span><br></pre></td></tr></table></figure>
<p> 以下面这个例子说明下上述代码如何使用。现在我需要给车的价值排个序，每次取出价值最低的车。为了方便，创建一个Car类。在上面代码中，我们是按照key的大小构造了二叉堆。按照这个意思我们应该把车的价值用insert方法加入到队列中，但是那样就无法获取其对应的车的信息。为此我们将每个车的对象加入到优先队列，按照它们的价值构造二叉堆，故要在Car类中定义比较大小的方法，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.value &lt; other.value <span class="keyword">or</span></span><br><span class="line">                (self.value == other.value <span class="keyword">and</span></span><br><span class="line">                 id(self.name) &lt; id(other.name)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.value &lt; other.value <span class="keyword">or</span></span><br><span class="line">                (self.value == other.value <span class="keyword">and</span></span><br><span class="line">                 id(self.name) &lt;= id(other.name)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.value &gt; other.value <span class="keyword">or</span></span><br><span class="line">                (self.value == other.value <span class="keyword">and</span></span><br><span class="line">                 id(self.name) &gt; id(other.name)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># :nodoc: Delegate comparison to distance.</span></span><br><span class="line">        <span class="keyword">return</span> (self.value &gt; other.value <span class="keyword">or</span></span><br><span class="line">                (self.value == other.value <span class="keyword">and</span></span><br><span class="line">                 id(self.name) &gt;= id(other.name)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   car1 = Car(<span class="string">"BMW"</span>, <span class="number">45</span>)</span><br><span class="line">   car2 = Car(<span class="string">"Maybach"</span>, <span class="number">145</span>)</span><br><span class="line">   car3 = Car(<span class="string">"Bugatti"</span>, <span class="number">85</span>)</span><br><span class="line">   car4 = Car(<span class="string">"Cadillac"</span>, <span class="number">78</span>)</span><br><span class="line">   car5 = Car(<span class="string">"Maserati"</span>, <span class="number">85</span>)</span><br><span class="line">   pq = PriorityQueue()</span><br><span class="line">   pq.insert(car1)</span><br><span class="line">   pq.insert(car2)</span><br><span class="line">   pq.insert(car3)</span><br><span class="line">   pq.insert(car4)</span><br><span class="line">   pq.insert(car5)</span><br><span class="line">   print(<span class="string">"队列大小：&#123;0&#125;"</span>.format(len(pq)))</span><br><span class="line">   print(pq.extract_min().name)</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># output:</span></span><br><span class="line">   <span class="comment"># 队列大小：5</span></span><br><span class="line"><span class="comment"># BMW</span></span><br></pre></td></tr></table></figure>
<p>BMW的价值最小，利用<code>extract_min</code>方法取出了car1对象，其<code>name</code>是BMW。</p>
<p>其实在python中已经有相关的模块可实现上述的优先队列的功能，如<code>heapq</code>模块，但只提供实现最小优先队列功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">q = []</span><br><span class="line"></span><br><span class="line">heapq.heappush(q, (<span class="number">2</span>, <span class="string">'code'</span>))</span><br><span class="line">heapq.heappush(q, (<span class="number">1</span>, <span class="string">'eat'</span>))</span><br><span class="line">heapq.heappush(q, (<span class="number">3</span>, <span class="string">'sleep'</span>))</span><br><span class="line"></span><br><span class="line">print(heapq.heappop(q))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output：(1, 'eat')</span></span><br></pre></td></tr></table></figure>
<p>还有queue中的<code>PriorityQueue</code>，其时间复杂度与heapq的一样，区别在于<code>PriorityQueue</code>是同步的，提供了锁语义来支持多个并发的生产者和消费者。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">q = PriorityQueue()</span><br><span class="line"></span><br><span class="line">q.put((<span class="number">2</span>, <span class="string">'code'</span>))</span><br><span class="line">q.put((<span class="number">1</span>, <span class="string">'eat'</span>))</span><br><span class="line">q.put((<span class="number">3</span>, <span class="string">'sleep'</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># output：(1, 'eat')</span></span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<p>1.算法导论第三版</p>
<p>2.<a href="https://geek-docs.com/python/python-examples/python-priority-queue.html" target="_blank" rel="noopener">https://geek-docs.com/python/python-examples/python-priority-queue.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/Heapsort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/Heapsort/" class="post-title-link" itemprop="url">Heapsort</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-09 17:23:36" itemprop="dateCreated datePublished" datetime="2020-08-09T17:23:36+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-10 13:15:47" itemprop="dateModified" datetime="2020-08-10T13:15:47+08:00">2020-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆排序（Heapsort）"><a href="#堆排序（Heapsort）" class="headerlink" title="堆排序（Heapsort）"></a>堆排序（Heapsort）</h3><h5 id="Heap-property"><a href="#Heap-property" class="headerlink" title="Heap property"></a>Heap property</h5><p>堆数据结构是数组对象，它可以用近似完全二叉树进行表示。例如下面数组A，可以表示成a图的二叉树形式。</p>
<p><img src="/2020/08/09/Heapsort/heap.png" alt="img"></p>
<p>设一节点的索引为i，从上图可以看到，其父节点的索引和子节点的索引与该节点的索引有如下关系：</p>
<script type="math/tex; mode=display">
parent(i) = i//2  \quad(// 表示取整)\\</script><script type="math/tex; mode=display">
left(i) = 2i\\</script><script type="math/tex; mode=display">
right(i) = 2i + 1\\</script><p>例如，元素14的索引为2，其父节点索引为2//2 = 1，左子节点索引为2x2 = 4, 右子节点为2x2+1 = 5</p>
<p>堆有最大堆（max heaps）和最小堆（min heaps）结构，两种结构分别满足不同的特性。对于max heaps，除根节点外，所有节点的父节点的值要大于或等于该节点的值。也即：</p>
<script type="math/tex; mode=display">
A[parent(i)] \ge A[i]</script><p>对于min heaps，其特性刚好相反：</p>
<script type="math/tex; mode=display">
A[parent(i)] \le A[i]</script><p>但是任意给出一个数组，不一定满足堆的上述特性，因此需要相应的操作来保持堆的特性，下面以max heaps为例，讲述堆的相关操作。</p>
<h5 id="Max-heapify"><a href="#Max-heapify" class="headerlink" title="Max heapify"></a>Max heapify</h5><p>max heapify是用来保持堆的特性，对某一节点，判断该节点是否满足堆的特性，如果不满足则将该节点移动合适的位置。</p>
<p><img src="/2020/08/09/Heapsort/heapify.png" alt="img"></p>
<p>如上图，元素4不满足最大堆的特性因为它要比14和7都要小，因此4需要和14和7中最大的一个元素互换位置，以保证父节点的值大于等于子节点的值。互换位置后再次判断是否满足特性，这时仍然不满足，因此需要再次移动直到图c的位置。</p>
<p>因为当移动节点后仍然是进行相同的操作：判断是否满足特性，不满足则移动。因此可以用递归的方式进行编写代码，程序的时间复杂度为O(logn)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr, n, i)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    arr:数组</span></span><br><span class="line"><span class="string">    n：数组的长度</span></span><br><span class="line"><span class="string">    i: 当前节点的索引</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    r = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    l = <span class="number">2</span>*i</span><br><span class="line">    <span class="comment"># 判断左子节点是否大于当前节点</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> arr[l] &gt; arr[i]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="comment"># 判断右子节点是否大于当前节点 </span></span><br><span class="line">    <span class="keyword">if</span> r &lt; n <span class="keyword">and</span> arr[r] &gt; arr[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="comment"># 不满足特性，交换节点位置，交换后再次进行heapify</span></span><br><span class="line">    <span class="keyword">if</span> largest <span class="keyword">is</span> <span class="keyword">not</span> i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br></pre></td></tr></table></figure>
<p>有了上述操作后，我们就可以根据数组来建立max heaps.</p>
<h5 id="Build-max-heaps"><a href="#Build-max-heaps" class="headerlink" title="Build max -heaps"></a>Build max -heaps</h5><p>堆的本质还是一个数组，Max-Heapify只是改变了元素的位置，使其满足最大堆的特性，因此需要对每一个元素检查其是否满足特性。但是A[n/2 + 1,…,n]这部分的元素都是子节点，因为2x(n/2 + 1)&gt;n，超出了索引范围，为此我们只需考虑前半部分的元素，其时间复杂度可以很容易得分析出为O(nlogn)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heaps</span><span class="params">(arr, n)</span>:</span></span><br><span class="line">    i = n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">        i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="Heapsort-algorithm"><a href="#Heapsort-algorithm" class="headerlink" title="Heapsort algorithm"></a>Heapsort algorithm</h5><p>建立好的最大堆如图c，第一个元素是数组中的最大的元素，而索引靠后的元素是数组中较小的元素。如果我们需要升序排序，那么每一次可以将第一个元素和最后一个元素交换，改变数组的元素排列。交换后利用max-heapify，保持最大堆特性，这时第一个元素是前n-1个元素中最大的元素，将其放在n-1的位置处，以此类推即可完成排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">	build_max_heaps(arr, n)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        arr[k], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[k]</span><br><span class="line">        heapify(arr, k, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">13</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">heapSort(arr)</span><br><span class="line">n = len(arr)</span><br><span class="line">print(<span class="string">"Sorted array is"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    print(<span class="string">" &#123;&#125;"</span>.format(arr[i]), end=<span class="string">""</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># output: </span></span><br><span class="line"><span class="comment"># Sorted array is</span></span><br><span class="line"><span class="comment"># 5 6 7 11 12 13</span></span><br></pre></td></tr></table></figure>
<p>整个程序的时间复杂度为O(nlogn)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-1/" class="post-title-link" itemprop="url">最短路径算法-1</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-09 17:23:36" itemprop="dateCreated datePublished" datetime="2020-08-09T17:23:36+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-10 10:04:35" itemprop="dateModified" datetime="2020-08-10T10:04:35+08:00">2020-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="最短路径算法-1"><a href="#最短路径算法-1" class="headerlink" title="最短路径算法-1"></a>最短路径算法-1</h3><p>BFS和DFS都可以用来找两点之间的最短路径，这里我将介绍其他几种最短路径的算法。</p>
<h5 id="爬山法（Hill-Climbing）"><a href="#爬山法（Hill-Climbing）" class="headerlink" title="爬山法（Hill-Climbing）"></a>爬山法（Hill-Climbing）</h5><p>在图的表示中，我介绍了如何自定义类来表示图，其中就有启发式距离的表示。爬山法是在DFS上基于启发式距离的一种算法。有点类似于贪婪算法，每一次选择离目标顶点最近的顶点进行遍历，因此只需对DFS的代码增加选取离目标最近顶点即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hill_climbing</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    pathlist=[(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">        curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">        curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">        new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">        <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">            new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes:</span><br><span class="line">            goal_path = curr_path + (goal, )</span><br><span class="line">            <span class="keyword">return</span> list(goal_path)</span><br><span class="line">        <span class="comment"># 根据启发式距离对顶点进行排序</span></span><br><span class="line">        dis = [(graph.get_heuristic(node, goal), node) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        dis = sorted(dis)</span><br><span class="line">        <span class="comment"># 取距离最近的顶点</span></span><br><span class="line">        new_nodes = [node[<span class="number">1</span>] <span class="keyword">for</span> node <span class="keyword">in</span> dis]</span><br><span class="line">        new_paths = [curr_path + (node,) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        new_paths.extend(pathlist)</span><br><span class="line">        pathlist = new_paths</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>爬山法运行起来要比DFS效率要高，因为省去了一些顶点，但是缺点在于容易陷入局部最优，而不能找到全局最优的路径。</p>
<h5 id="集束搜索（Beam-Search）"><a href="#集束搜索（Beam-Search）" class="headerlink" title="集束搜索（Beam Search）"></a>集束搜索（Beam Search）</h5><p>前面的爬山法是在DFS算法基础上改进的，而集束搜索是在BFS算法基础上改进的。BFS会遍历每一层级的所有顶点，而集束搜索会选择前k个离目标顶点的启发式距离最近的顶点进行遍历，k称为集束宽度（beam width）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beam_search</span><span class="params">(graph, start, goal, beam_width)</span>:</span></span><br><span class="line">    pathlist = [(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">        new_paths = []</span><br><span class="line">        <span class="comment"># 取前beam_width个路径</span></span><br><span class="line">        pathlist = pathlist[:beam_width]</span><br><span class="line">        <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">            curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">            curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">            new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">            <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">                new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">            <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes:</span><br><span class="line">                goal_path = curr_path + (goal,)</span><br><span class="line">                <span class="keyword">return</span> list(goal_path)</span><br><span class="line">            new_paths += [curr_path + (node,) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        pathlist.extend(new_paths)</span><br><span class="line">        <span class="comment"># sort pathlist</span></span><br><span class="line">        dis = [(graph.get_heuristic(path[<span class="number">-1</span>], goal), path) <span class="keyword">for</span> path <span class="keyword">in</span> pathlist]</span><br><span class="line">        dis = sorted(dis)</span><br><span class="line">        pathlist = [path[<span class="number">1</span>] <span class="keyword">for</span> path <span class="keyword">in</span> dis]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h5 id="分支界定法（branch-and-bound）"><a href="#分支界定法（branch-and-bound）" class="headerlink" title="分支界定法（branch and bound）"></a>分支界定法（branch and bound）</h5><p>前面的两种算法都是基于启发式距离，而路径最短往往说的是实际的路径长度，分支界定法就是基于实际的路径长度，每次选路径最短进行遍历。因此需要一个方法来统计到目前顶点的累积路径长度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_length</span><span class="params">(graph, node_names)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    node_names:遍历过的顶点</span></span><br><span class="line"><span class="string">    return:返回累积路径长度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(node_names) - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> graph.are_connected(node_names[i], node_names[i+<span class="number">1</span>]):</span><br><span class="line">            length += graph.get_edge(node_names[i], node_names[i+<span class="number">1</span>]).length</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>
<p>同时，只需将爬山法的对启发式距离排序的程序改为对所有路径按累积路径长度进行排序即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">branch_and_bound</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    pathlist = [(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    goal_path = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">        curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">        curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">        new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">        <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">            new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes <span class="keyword">and</span> goal_path:</span><br><span class="line">            new_goal_path = curr_path + (goal,)</span><br><span class="line">            <span class="keyword">if</span> path_length(graph, new_goal_path) &lt; path_length(graph, goal_path):</span><br><span class="line">                goal_path = new_goal_path</span><br><span class="line">        <span class="keyword">elif</span> goal <span class="keyword">in</span> new_nodes <span class="keyword">and</span> <span class="keyword">not</span> goal_path:</span><br><span class="line">            goal_path = curr_path + (goal,)</span><br><span class="line">        new_paths = [curr_path + (node,) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        new_paths.extend(pathlist)</span><br><span class="line">        pathlist = new_paths</span><br><span class="line">        <span class="comment"># 按路径长度对所有路径进行排序</span></span><br><span class="line">        dis = [(path_length(graph, path), path) <span class="keyword">for</span> path <span class="keyword">in</span> pathlist]</span><br><span class="line">        dis = sorted(dis)</span><br><span class="line">        <span class="comment"># 取最短的路径</span></span><br><span class="line">        pathlist = [path[<span class="number">1</span>] <span class="keyword">for</span> path <span class="keyword">in</span> dis]</span><br><span class="line">    <span class="keyword">if</span> goal_path:</span><br><span class="line">        <span class="keyword">return</span> list(goal_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h5 id="A-算法"><a href="#A-算法" class="headerlink" title="A* 算法"></a>A* 算法</h5><p>A*算法是同时基于累积路径长度和启发式距离的算法，对于程序的编写，我们只需在上述代码中增加启发式距离即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_star</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    pathlist = [(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    goal_path = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> goal_path:</span><br><span class="line">        curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">        curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">        new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">        <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">            new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes:</span><br><span class="line">            goal_path = curr_path + (goal,)</span><br><span class="line">        new_paths = [curr_path + (node,) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        new_paths.extend(pathlist)</span><br><span class="line">        pathlist = new_paths</span><br><span class="line">        <span class="comment"># 按 累计长度+启发式距离 对所有路径进行排序</span></span><br><span class="line">        dis = [(path_length(graph, path)+graph.get_heuristic(path[<span class="number">-1</span>], goal),</span><br><span class="line">                path) <span class="keyword">for</span> path <span class="keyword">in</span> pathlist]</span><br><span class="line">        dis = sorted(dis)</span><br><span class="line">        pathlist = [path[<span class="number">1</span>] <span class="keyword">for</span> path <span class="keyword">in</span> dis]</span><br><span class="line">    <span class="keyword">if</span> goal_path:</span><br><span class="line">        <span class="keyword">return</span> list(goal_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>A<em> 算法是其中效率比较高的算法，但其运行的好坏，在于启发式距离设定的好坏。如果get_heuristic(node, goal)始终小于等于节点node到goal的实际距离，则A</em>算法保证一定能够找到最短路径。但是当get_heuristic(node, goal)的值越小，算法将遍历越多的节点，也就导致算法越慢。</p>
<p>如果get_heuristic(node, goal)大于节点node到goal的实际距离，则A*算法不能保证找到最短路径，不过此时会很快。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/DFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/DFS/" class="post-title-link" itemprop="url">DFS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-09 16:28:51" itemprop="dateCreated datePublished" datetime="2020-08-09T16:28:51+08:00">2020-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h3><p>DFS也是一种常见的图的搜索算法，与BFS不同，DFS不按层级遍历，而是从一条路径遍历到末尾，再返回原来的路径，选择另一路径继续相同的操作，直到全部遍历完成，或到达停止的条件，这一过程类似于走迷宫一样。因此我们还可以用递归的方法实现DFS算法。</p>
<p>在BFS算法中，我们借助了队列的数据结构，遵循先进先出原则，从而实现对每一层级的遍历。与之相反，在DFS，我们需要借助堆栈的数据结构，遵循后进先出原则，从而实现深度优先。</p>
<p>非递归方法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_1</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return:返回依次序遍历的顶点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    visited, stack = set(), [start]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        vertex = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> vertex <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(vertex)</span><br><span class="line">            stack.extend(set(graph.get_connected_nodes(vertex)) - visited)</span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure>
<p>递归方法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_rec</span><span class="params">(graph, node, visited=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return:返回依次序遍历的顶点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = []</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">        visited.append(node)</span><br><span class="line">        <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph.get_connected_nodes(node):</span><br><span class="line">            dfs_rec(graph, neighbour, visited)</span><br><span class="line">    <span class="keyword">return</span> visited</span><br></pre></td></tr></table></figure>
<p>如果需要寻找两个顶点间的最短路径，可以采用类似在BFS中找最短路径的方法，代码结构基本一致，其中的细节需要做如下改动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_path</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param graph:</span></span><br><span class="line"><span class="string">    :param start:</span></span><br><span class="line"><span class="string">    :param goal:</span></span><br><span class="line"><span class="string">    :return: return the path from start to goal, when the goal is found, the</span></span><br><span class="line"><span class="string">    programme will stop.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pathlist=[(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">        curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">        curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">        new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">        <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">            new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes:</span><br><span class="line">            goal_path = curr_path + (goal, )</span><br><span class="line">            <span class="keyword">return</span> goal_path</span><br><span class="line">        new_paths = [curr_path + (node, ) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        new_paths.extend(pathlist)</span><br><span class="line">        pathlist = new_paths</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>同时，如果需要找到所有的路径，基本思路与BFS的类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs_all_path</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param graph:</span></span><br><span class="line"><span class="string">    :param start:</span></span><br><span class="line"><span class="string">    :param goal:</span></span><br><span class="line"><span class="string">    :return: return the list of all the paths from start to goal</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = [(start, [start])]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        (vertex, path) = stack.pop()</span><br><span class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> set(graph.get_connected_nodes(vertex)) - set(path):</span><br><span class="line">            <span class="keyword">if</span> next == goal:</span><br><span class="line">                <span class="keyword">yield</span> path + [next]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append((next, path + [next]))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/BFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/BFS/" class="post-title-link" itemprop="url">BFS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-09 11:53:30" itemprop="dateCreated datePublished" datetime="2020-08-09T11:53:30+08:00">2020-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h3><p>图的应用中，最重要的一部分就是图的搜索和遍历，图的搜索算法有很多，而BFS是其中一种比较简单的搜索算法。算法核心在于，从初始顶点开始，一层一层遍历搜索顶点，直到所有顶点搜索完毕，如下图所示：</p>
<p><img src="/2020/08/09/BFS/BFS.png" alt="img"></p>
<p>实现这个算法，我们首先定义level字典，保存每个vertex的层级信息，frontier列表用来保存上一层级遍历过的vertex，parent字典用来保存每个vertex的上一个vertex。为此代码的思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化：level，frontier，parent 保存初始顶点</span><br><span class="line">遍历frontier的所有顶点：</span><br><span class="line">	定义next列表，保存下一次需要遍历的顶点</span><br><span class="line">	遍历所有与frontier中顶点相连的其他顶点：</span><br><span class="line">		如果不在level中即没有遍历：</span><br><span class="line">			更新level，parent，next</span><br><span class="line">	frontier &#x3D; next</span><br><span class="line">	层级加一</span><br></pre></td></tr></table></figure>
<p>因此我们的代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_1</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return: 被遍历的顶点次序和level字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    level = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line">    parent = &#123;start: <span class="literal">None</span>&#125;</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    frontier = [start]</span><br><span class="line">    node_visited = [start]</span><br><span class="line">    <span class="keyword">while</span> frontier:</span><br><span class="line">        next = []</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> frontier:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph.get_connected_nodes(u):</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> level:</span><br><span class="line">                    level[v] = i</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">                    node_visited.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node_visited, level</span><br></pre></td></tr></table></figure>
<p>根据BFS的核心思想，我们可以对代码进行不同版本的修改，比如利用队列的特性，可以将上述代码简化，结果返回遍历顶点的次序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_2</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">    explore = []</span><br><span class="line">    queue = [start]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> explore:</span><br><span class="line">            explore.append(node)</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.get_connected_nodes(node):</span><br><span class="line">                queue.append(neighbor)</span><br><span class="line">    <span class="keyword">return</span> explore</span><br></pre></td></tr></table></figure>
<p>如果需要用BFS找到两点之间的最短路径，可以将第一版的代码修改如下：</p>
<p>在for循环中增加是否找到目标顶点的判断条件，如果是则结束遍历，reach_goal标志设为true，最后利用parent字典，反向遍历找到start到goal的路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_path</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    level = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line">    parent = &#123;start: <span class="literal">None</span>&#125;</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    frontier = [start]</span><br><span class="line">    node_visited = [start]</span><br><span class="line">    reach_goal = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> frontier:</span><br><span class="line">        next = []</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> frontier:</span><br><span class="line">            <span class="keyword">if</span> goal <span class="keyword">in</span> graph.get_connected_nodes(u):</span><br><span class="line">                parent[goal] = u</span><br><span class="line">                reach_goal = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph.get_connected_nodes(u):</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> level:</span><br><span class="line">                    level[v] = i</span><br><span class="line">                    parent[v] = u</span><br><span class="line">                    next.append(v)</span><br><span class="line">                    node_visited.append(v)</span><br><span class="line">        frontier = next</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> reach_goal:</span><br><span class="line">        pathlist = []</span><br><span class="line">        temp = goal</span><br><span class="line">        <span class="keyword">while</span> temp:</span><br><span class="line">            pathlist.append(temp)</span><br><span class="line">            temp = parent[temp]</span><br><span class="line">        pathlist.reverse()</span><br><span class="line">        <span class="keyword">return</span> pathlist</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>第二种方法没有用parent字典，它是保存当前的路径，从而无需对parent字典反向遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_path_2</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    pathlist = [(start,)]</span><br><span class="line">    <span class="keyword">if</span> start == goal:</span><br><span class="line">        <span class="keyword">return</span> [start]</span><br><span class="line">    <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">        new_paths = []</span><br><span class="line">        <span class="keyword">while</span> len(pathlist) &gt; <span class="number">0</span>:</span><br><span class="line">            curr_path = pathlist.pop(<span class="number">0</span>)</span><br><span class="line">            curr_node = curr_path[<span class="number">-1</span>]</span><br><span class="line">            new_nodes = graph.get_connected_nodes(curr_node)</span><br><span class="line">            <span class="comment"># 更新顶点信息</span></span><br><span class="line">            <span class="keyword">if</span> len(curr_path) &gt; <span class="number">1</span>:</span><br><span class="line">                new_nodes = [node <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> curr_path]</span><br><span class="line">            <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes:</span><br><span class="line">                goal_path = curr_path + (goal,)</span><br><span class="line">                <span class="keyword">return</span> goal_path</span><br><span class="line">            <span class="comment"># 更新路径信息</span></span><br><span class="line">            new_paths += [curr_path + (node,) <span class="keyword">for</span> node <span class="keyword">in</span> new_nodes]</span><br><span class="line">        pathlist.extend(new_paths)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>如果需要找到从初始顶点到目标顶点的所有路径，我们只需修改找到目标顶点的判断条件即可，使程序继续执行，这里我们可以利用yield关键字，同时利用集合的差集运算，去掉已经遍历过的顶点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_allpaths</span><span class="params">(graph, start, goal)</span>:</span></span><br><span class="line">    queue = [(start, [start])]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        (vertex, path) = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> set(graph.get_connected_nodes(vertex)) - set(path):</span><br><span class="line">            <span class="keyword">if</span> next == goal:</span><br><span class="line">                <span class="keyword">yield</span> path + [next]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append((next, path + [next]))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bania">
      <meta itemprop="description" content="A platform for discussing programming and technology">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaniaBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/Graph/" class="post-title-link" itemprop="url">Graph</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-09 11:02:21 / Modified: 11:02:22" itemprop="dateCreated datePublished" datetime="2020-08-09T11:02:21+08:00">2020-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="图（Graph）的表示"><a href="#图（Graph）的表示" class="headerlink" title="图（Graph）的表示"></a>图（Graph）的表示</h4><h5 id="1-图的概念"><a href="#1-图的概念" class="headerlink" title="1.图的概念"></a>1.图的概念</h5><p>图是一种重要的数据结构，在解决实际问题中也经常用到这种数据结构，其基本表示为G=(V, E)，V(vectex)是图的顶点，E(edge)表示图的边。我们的地图在计算机中就可以表示成一个Graph，不同的标志性地点为vectex，地点之间的路表示为edge，这样就可以方便操作实际中的地图去解决一些复杂的问题，比如找两个地点之间的最短路径，旅行商问题等等。</p>
<p>图分为有向图和无向图，有向图指的是各个顶点之间有一定的方向，一个顶点到另一个顶点需要按照给定的方向进行移动；而无向图指的是顶点之间没有固定方向。如下图所示，第一幅图为无向图，第二幅图为有向图。在有向图中，顶点1指向顶点2，说明1可以移向2，但是2不能移向1。</p>
<p><img src="/2020/08/09/Graph/有向图.png" alt="img"></p>
<p><img src="/2020/08/09/Graph/无向图.png" alt="img"></p>
<h5 id="2-图的表示"><a href="#2-图的表示" class="headerlink" title="2.图的表示"></a>2.图的表示</h5><p>图的表示就是表示清楚顶点信息和边的信息。有两种表示方法，邻接链表和邻接矩阵。如上面两张图可分别表示如下：</p>
<p><img src="/2020/08/09/Graph/图的表示1.png" alt="img"></p>
<p><img src="/2020/08/09/Graph/图的表示2.png" alt="img"></p>
<p>在计算机中，我们可以使用一些数据结构来简化图的表达，比如在Python中，我们可以用下面代码来表示一个图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;<span class="string">'A'</span>: set([<span class="string">'B'</span>, <span class="string">'C'</span>]),</span><br><span class="line">         <span class="string">'B'</span>: set([<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]),</span><br><span class="line">         <span class="string">'C'</span>: set([<span class="string">'A'</span>, <span class="string">'F'</span>]),</span><br><span class="line">         <span class="string">'D'</span>: set([<span class="string">'B'</span>]),</span><br><span class="line">         <span class="string">'E'</span>: set([<span class="string">'B'</span>, <span class="string">'F'</span>]),</span><br><span class="line">         <span class="string">'F'</span>: set([<span class="string">'C'</span>, <span class="string">'E'</span>])&#125;</span><br></pre></td></tr></table></figure>
<p>graph是一个字典，其中keys是所有的vertices，values是与该顶点连接的其他顶点。如果我们需要获取所有的顶点，那么可以利用字典的keys()方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph.keys()</span><br><span class="line"></span><br><span class="line">output: dict_keys([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>])</span><br></pre></td></tr></table></figure>
<p>获取与某个顶点相连的其他顶点，就可直接利用字典的取值方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph[<span class="string">'A'</span>]</span><br><span class="line"></span><br><span class="line">output: &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果图中的每一个边有权，我们称之为有权图时，利用上述的表示方法不能很方便地得到权重信息，为此我们可以封装一个类，定义获取边，权重等相关信息的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fall 2012 6.034 Lab 2: Search</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    set()</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    <span class="keyword">from</span> sets <span class="keyword">import</span> Set <span class="keyword">as</span> set, ImmutableSet <span class="keyword">as</span> frozenset</span><br><span class="line"></span><br><span class="line">NAME=<span class="string">"NAME"</span></span><br><span class="line">NODE1=<span class="string">"NODE1"</span></span><br><span class="line">NODE2=<span class="string">"NODE2"</span></span><br><span class="line">VAL=<span class="string">"LENGTH"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, node1, node2, length)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.node1 = node1</span><br><span class="line">        self.node2 = node2</span><br><span class="line">        self.length = length</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Edge '</span> + self.name + \</span><br><span class="line">               <span class="string">' from '</span> + self.node1 + <span class="string">' to '</span> + self.node2 + \</span><br><span class="line">               <span class="string">' with length '</span> + str(self.length)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nodes=None, edgesdict=None, heuristic=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 edges=None)</span>:</span></span><br><span class="line">        <span class="string">'''specify EITHER edgesdict OR edges'''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> edges:</span><br><span class="line">            self.edges = edges</span><br><span class="line">        <span class="keyword">elif</span> edgesdict:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.edges = [Edge(e[<span class="string">'NAME'</span>], e[<span class="string">'NODE1'</span>], e[<span class="string">'NODE2'</span>], e[<span class="string">'LENGTH'</span>])\</span><br><span class="line">                              <span class="keyword">for</span> e <span class="keyword">in</span> edgesdict]</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                self.edges = [Edge(e[<span class="string">'name'</span>], e[<span class="string">'node1'</span>], e[<span class="string">'node2'</span>], e[<span class="string">'length'</span>])\</span><br><span class="line">                              <span class="keyword">for</span> e <span class="keyword">in</span> edgesdict]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.edges = []</span><br><span class="line">        self.nodes = nodes</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">            self.nodes = list(set([edge.node1 <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges] + </span><br><span class="line">                                  [edge.node2 <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges]))</span><br><span class="line">        <span class="comment"># heuristic is a dictionary where heuristic[G][S] is the</span></span><br><span class="line">        <span class="comment">#  heuristic distance from S to G</span></span><br><span class="line">        self.heuristic = heuristic</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> heuristic:</span><br><span class="line">            self.heuristic = &#123;&#125;</span><br><span class="line">        self.validate()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.nodes:</span><br><span class="line">            <span class="keyword">assert</span> isinstance(name, str), str(type(name))+<span class="string">": "</span>+str(name)</span><br><span class="line">        <span class="keyword">assert</span> len(self.nodes) == len(set(self.nodes)), <span class="string">"no duplicate nodes"</span></span><br><span class="line">        edgenames = [edge.name <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges]</span><br><span class="line">        <span class="keyword">assert</span> len(edgenames) == len(set(edgenames)), <span class="string">"no duplicate edges"</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges:</span><br><span class="line">            <span class="keyword">assert</span> isinstance(edge.name, str), type(edge.name)</span><br><span class="line">            <span class="keyword">assert</span> edge.node1 <span class="keyword">in</span> self.nodes</span><br><span class="line">            <span class="keyword">assert</span> edge.node2 <span class="keyword">in</span> self.nodes</span><br><span class="line">            <span class="keyword">assert</span> edge.length &gt; <span class="number">0</span>, <span class="string">"positive edges only today"</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> self.nodes:</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> self.nodes:</span><br><span class="line">                <span class="keyword">assert</span> self.get_heuristic(start,end) &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_connected_nodes</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        gets a list of all node id values connected to a given node.</span></span><br><span class="line"><span class="string">        'node' should be a node name, not a dictionary.</span></span><br><span class="line"><span class="string">        The return value is a list of node names.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> node <span class="keyword">in</span> self.nodes, <span class="string">"No node "</span>+str(node)+<span class="string">" in graph "</span>+str(self)</span><br><span class="line">        result = [x.node2 <span class="keyword">for</span> x <span class="keyword">in</span> self.edges <span class="keyword">if</span> x.node1 == node]</span><br><span class="line">        result += [x.node1 <span class="keyword">for</span> x <span class="keyword">in</span> self.edges <span class="keyword">if</span> x.node2 == node]</span><br><span class="line">        <span class="keyword">return</span> sorted(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_edge</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        checks the list of edges and returns an edge if</span></span><br><span class="line"><span class="string">        both connected nodes are part of the edge, or 'None' otherwise.</span></span><br><span class="line"><span class="string">        'node1' and 'node2' are names of nodes, not 'NODE' dictionaries.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> node1 <span class="keyword">in</span> self.nodes, <span class="string">"No node "</span>+str(node1)+<span class="string">" in graph "</span>+str(self)</span><br><span class="line">        <span class="keyword">assert</span> node2 <span class="keyword">in</span> self.nodes, <span class="string">"No node "</span>+str(node2)+<span class="string">" in graph "</span>+str(self)</span><br><span class="line">        node_names = ( node1, node2 )</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges:</span><br><span class="line">            <span class="keyword">if</span> ((edge.node1, edge.node2) == node_names <span class="keyword">or</span> </span><br><span class="line">                (edge.node2, edge.node1) == node_names):</span><br><span class="line">                <span class="keyword">return</span> edge</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">are_connected</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        checks if two edges are connected.</span></span><br><span class="line"><span class="string">        'node1' and 'node2' are names of nodes, not 'NODE' dictionaries.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.get_edge(node1, node2) )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_heuristic</span><span class="params">(self, start, goal)</span>:</span></span><br><span class="line">        <span class="string">""" Return the value of the heuristic from the start to the goal"""</span></span><br><span class="line">        <span class="keyword">assert</span> start <span class="keyword">in</span> self.nodes, <span class="string">"No node "</span>+str(start)+<span class="string">" in graph "</span>+str(self)</span><br><span class="line">        <span class="keyword">assert</span> goal <span class="keyword">in</span> self.nodes, <span class="string">"No node "</span>+str(goal)+<span class="string">" in graph "</span>+str(self)</span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">in</span> self.heuristic:</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">in</span> self.heuristic[goal]:</span><br><span class="line">                <span class="keyword">return</span> self.heuristic[goal][start]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># we have checked that everything is positive</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># we have checked that everything is positive</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid_path</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid_path_reducer</span><span class="params">(elt_a, elt_b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> elt_a == <span class="literal">False</span> <span class="keyword">or</span> <span class="keyword">not</span> self.are_connected(elt_a, elt_b):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> elt_b</span><br><span class="line">        <span class="keyword">return</span> (reduce(is_valid_path_reducer, path) != <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(self, node1, node2, length, name=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node1 <span class="keyword">not</span> <span class="keyword">in</span> self.nodes:</span><br><span class="line">            self.nodes.append(node1)</span><br><span class="line">        <span class="keyword">if</span> node2 <span class="keyword">not</span> <span class="keyword">in</span> self.nodes:</span><br><span class="line">            self.nodes.append(node2)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="literal">None</span>:</span><br><span class="line">            name = (<span class="string">"%s %s"</span> % (node1, node2))</span><br><span class="line">        self.edges.append(Edge(name, node1, node2, length))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_heuristic</span><span class="params">(self, start, goal, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> goal <span class="keyword">not</span> <span class="keyword">in</span> self.heuristic:</span><br><span class="line">            self.heuristic[goal] = &#123;&#125;</span><br><span class="line">        self.heuristic[goal][start] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Graph: \n  edges="</span>+str(self.edges)+<span class="string">"\n  heuristic="</span>+str(self.heuristic)</span><br></pre></td></tr></table></figure>
<p>根据init方法的定义，一个图可以如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AGRAPH = Graph(nodes = [<span class="string">'S'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'G'</span>],</span><br><span class="line">               edgesdict = [&#123;<span class="string">'NAME'</span>: <span class="string">'eSA'</span>, <span class="string">'LENGTH'</span>: <span class="number">3</span>, <span class="string">'NODE1'</span>: <span class="string">'S'</span>, <span class="string">'NODE2'</span>: <span class="string">'A'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'NAME'</span>: <span class="string">'eSB'</span>, <span class="string">'LENGTH'</span>: <span class="number">1</span>, <span class="string">'NODE1'</span>: <span class="string">'S'</span>, <span class="string">'NODE2'</span>: <span class="string">'B'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'NAME'</span>: <span class="string">'eAB'</span>, <span class="string">'LENGTH'</span>: <span class="number">1</span>, <span class="string">'NODE1'</span>: <span class="string">'A'</span>, <span class="string">'NODE2'</span>: <span class="string">'B'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'NAME'</span>: <span class="string">'eAC'</span>, <span class="string">'LENGTH'</span>: <span class="number">1</span>, <span class="string">'NODE1'</span>: <span class="string">'A'</span>, <span class="string">'NODE2'</span>: <span class="string">'C'</span>&#125;,</span><br><span class="line">                            &#123;<span class="string">'NAME'</span>: <span class="string">'eCG'</span>, <span class="string">'LENGTH'</span>: <span class="number">10</span>, <span class="string">'NODE1'</span>: <span class="string">'C'</span>, <span class="string">'NODE2'</span>: <span class="string">'G'</span>&#125;],</span><br><span class="line">               heuristic = &#123;<span class="string">'G'</span>:&#123;<span class="string">'S'</span>: <span class="number">12</span>,</span><br><span class="line">                                 <span class="string">'A'</span>: <span class="number">9</span>,</span><br><span class="line">                                 <span class="string">'B'</span>: <span class="number">12</span>,</span><br><span class="line">                                 <span class="string">'C'</span>: <span class="number">8</span>,</span><br><span class="line">                                 <span class="string">'G'</span>: <span class="number">0</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>heuristic是启发式的距离，在A*算法中会使用到这个属性，这里不做过多的描述。我们只需明白图的表示可以很灵活多样，但关键在于把需要的信息表达清楚即可，特别是顶点和边的信息。对于不同问题，我们可以使用不同的数据结构和算法对图进行表示。</p>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p>1.算法导论第三版</p>
<p>2.MIT Artificial Intelligence open course Assignment lab2 code </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bania</p>
  <div class="site-description" itemprop="description">A platform for discussing programming and technology</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bania</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
  Total visits: <span id="busuanzi_value_site_pv"></span> times
  <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
  <span id="busuanzi_value_site_uv"></span>people have viewed my bolg.
</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
        loader: {
          load: ['[tex]/mhchem']
        },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
